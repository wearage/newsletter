import asyncio
import logging
import os
import openai
import asyncpg
from dotenv import load_dotenv
from pyrogram import Client
import pandas as pd
from asyncpg import exceptions
import argparse
from datetime import datetime, timedelta
import re
from collections import defaultdict
import json  # Добавлено для работы с JSON

# Инициализация контекста и словаря сообщений для каждого пользователя
context = defaultdict(list)
user_messages = defaultdict(list)
timers = {}

# Загрузка переменных окружения из .env файла
load_dotenv()
openai.api_key = os.getenv("OPENAI_API_KEY")

# Настройка логгера
log_filename = os.path.join(os.path.dirname(__file__), 'script_logs.txt')
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(log_filename, encoding='utf-8'),
        logging.StreamHandler()
    ]
)

# Загрузка аргументов командной строки
parser = argparse.ArgumentParser(description="Запуск скрипта с уникальным именем индекса")
parser.add_argument('--index_name', type=str, required=True, help='Уникальное имя индекса для скрипта')
args = parser.parse_args()

index_name = args.index_name

# Путь к Excel файлу с юзернеймами
EXCEL_FILE = '/opt/Project501/usernames.xlsx'
COLUMN_NAME = 'Script1'
COLUMN_NAME = 'Script1name'
BATCH_SIZE = 2

# Путь к директории логов
LOGS_DIR = '/opt/Project501/Logs'
os.makedirs(LOGS_DIR, exist_ok=True)

# Асинхронное подключение к базе данных PostgreSQL
async def create_db_connection():
    return await asyncpg.connect(
        database=os.getenv("DB_NAME"),
        user=os.getenv("DB_USER"),
        password=os.getenv("DB_PASSWORD"),
        host=os.getenv("DB_HOST"),
        port=os.getenv("DB_PORT")
    )

# Создание таблицы статистики и индекса, если их нет
async def create_tables():
    conn = await create_db_connection()
    await conn.execute("""
    CREATE TABLE IF NOT EXISTS user_stats (
        id SERIAL PRIMARY KEY,
        username VARCHAR(255) UNIQUE NOT NULL,
        user_replied BOOLEAN DEFAULT FALSE,
        message_count INT DEFAULT 0,
        sensitive_info_sent BOOLEAN DEFAULT FALSE,
        initial_message_sent BOOLEAN DEFAULT FALSE,
        qualification VARCHAR(50),
        summary TEXT,
        monthly_budget INT,
        consultation_agreed BOOLEAN,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    """)
    await conn.execute("""
    CREATE TABLE IF NOT EXISTS processing_index (
        id SERIAL PRIMARY KEY,
        index_name VARCHAR(255) UNIQUE NOT NULL,
        current_index INT DEFAULT 0
    );
    """)
    await conn.close()

# Вызов функции создания таблиц
async def initialize_tables():
    await create_tables()

# Функция для получения текущего индекса из базы данных
async def get_current_index(conn, index_name):
    row = await conn.fetchrow("""
        SELECT current_index FROM processing_index WHERE index_name=$1;
    """, index_name)
    if row:
        print(f"Индекс найден для {index_name}: {row['current_index']}")
        return row['current_index']
    else:
        print(f"Индекс не найден для {index_name}, создаем новый.")
        await conn.execute("""
            INSERT INTO processing_index (index_name, current_index) VALUES ($1, 0)
            ON CONFLICT (index_name) DO NOTHING;
        """, index_name)
        return 0

# Функция для обновления индекса в базе данных
async def update_current_index(conn, new_index, index_name):
    await conn.execute("""
        UPDATE processing_index SET current_index=$1 WHERE index_name=$2;
    """, new_index, index_name)
    print(f"Индекс обновлен для {index_name}: {new_index}")

# Асинхронная функция для обновления статистики
async def log_and_update_stats_db(conn, username, user_replied, message_count, sensitive_info_sent,
                                  initial_message_sent, qualification=None, summary=None,
                                  monthly_budget=None, consultation_agreed=None):
    try:
        print(f"Запись в БД: username={username}, user_replied={user_replied}, message_count={message_count}, "
              f"sensitive_info_sent={sensitive_info_sent}, initial_message_sent={initial_message_sent}, "
              f"qualification={qualification}, summary={summary}, monthly_budget={monthly_budget}, "
              f"consultation_agreed={consultation_agreed}")
        await conn.execute("""
            INSERT INTO user_stats (
                username, user_replied, message_count, sensitive_info_sent, 
                initial_message_sent, qualification, summary, monthly_budget, 
                consultation_agreed
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            ON CONFLICT (username) 
            DO UPDATE SET 
                user_replied = EXCLUDED.user_replied,
                message_count = EXCLUDED.message_count,
                sensitive_info_sent = EXCLUDED.sensitive_info_sent,
                initial_message_sent = EXCLUDED.initial_message_sent,
                qualification = EXCLUDED.qualification,
                summary = EXCLUDED.summary,
                monthly_budget = EXCLUDED.monthly_budget,
                consultation_agreed = EXCLUDED.consultation_agreed,
                updated_at = CURRENT_TIMESTAMP;
        """, username, user_replied, message_count, sensitive_info_sent, initial_message_sent,
           qualification, summary, monthly_budget, consultation_agreed)
    except exceptions.PostgresError as e:
        print(f"Ошибка при записи в базу данных: {e}")

# Функция для чтения одного юзернейма из Excel файла
def load_single_username_from_excel(username_column, name_column, start_index):
    df = pd.read_excel(EXCEL_FILE)
    usernames = df[username_column].dropna().tolist()
    names = df[name_column].dropna().tolist()

    if start_index >= len(usernames):
        return None, None, start_index

    return usernames[start_index], names[start_index], start_index + 1



# Список аккаунтов с данными для авторизации
accounts = [{'session_name': '+79863547134'}]

# Определение начального сообщения (будет заменено новым промптом)
initial_message = (
   "Script1name, Здравствуйте! Заметила вас в общем чате)\n\n"
   "Мы реализуем инновационное решение, которое поможет создавать разговорные видео, не тратя время на съемки!\n\n"
   "Хотели бы узнать больше о том, как эта технология может быть полезна для вас?"
)

# Промпт для первой нейросети
prompt_template_1 = [
    {
        "role": "system",
        "content": (
            "Ты - Анастасия, менеджер компании Launch Ai."
            "Действуй строго по шагам:"
            "#Шаг 0. Проанализируй ответ пользователя, если он не высказал возражений, тио переходи к шагу 1, если пользователь высказал сомнения или возражения, то переходи к шагу 2"
            "#Шаг 1. Задай клиенту этот вопрос, разбив его на 3 абзаца: 'Ниже я прикреплю наше коммерческое предложение, чтобы вы смогли подробнее ознакомиться снашим предложением)\n\nИ если не сложно, попрошу ответить буквально на пару вопросов, после чего с вами свяжется менеджер для дальнейшей консультации)\n\nВедете ли вы свои соцсети?'. Затем переходи к шагу 2"
            "#Шаг 2. Проанализируй ответ пользователя"
            "Если пользователь ответил на вопрос ведет ли он свои соцсети, то просто ответь 'Хорошо <3'. "
            "Если пользователь не дал четкого ответа на вопрос ведет ли свои соцсети, то переходи к шагу 3 "
            "Если пользователь ответил, но еще высказал возражения, то просто ответь 'Хорошо <3' "
            "#Шаг 3. Найди как ответить пользователю на его возражение в {Ответы на вопросы} и ответь пользователю, разбей сообщение на 2 абзаца, во втором спроси у пользователя 'Скажите пожалуйста, ведете вы свои соц сети?'" 
            "Никогда не здоровайся"
            "Если клиент отказывается от диалога и пишет 'нет' или  'не интересно', то вежливо попрощайся с ним и скажи, что ты всегда готова ответить на его вопросы если он передумает, не используй слово 'понимаю'"
            "Если клиент спрашивает делаем ли мы 'пробное видео', то отправь ему контакты менеджера 'С вами свяжется наш менеджер в ближайшее время.\nЕго аккаунт: [@AI_griban](https://t.me/AI_griban).\' обязательно добавь хештег #спасибо"
            
            "# ОТВЕТЫ НА ВОПРОСЫ:\n"

            "# Если клиент спрашивает, почему наши видео будут лучше, чем его собственные, или интересуется конверсией:\n"
            "  \"Объясните, что мы используем сразу несколько нейросетей для создания уникального контента.\n"
            "  Сообщите, что за основу берём уже популярные видео с миллионами просмотров из его или смежной темы, что обеспечивает высокие просмотры и повышает конверсию.\"\n\n"


            "# Если у клиента возникают сомнения, то подчеркни преимущества нашего сервиса:\n"
            "  \"Наше уникальное решение позволяет вам получать готовые видео быстро и без лишних усилий. ИИ создаёт сценарии и генерирует видео автоматически.\"\n"
            "  \"Это поможет вам сэкономить время и избежать задержек.\"\n\n"


            "#  Если клиент спрашивает про стоимость услуги, то скажи что базовая стоимость видео, длительностью до одной минуты, составляет 2000 рублей. Подробнее о тарифах можно узнать на консультации с менеджером.\n\n"
 

           "# Если клиент спрашивает про кейсы работы:\n"
            "  \"Скажите, что с удовольствием поделитесь кейсами работы с данным методом.\n"
            "  Упомяните, что технология новая и начала массово использоваться несколько месяцев назад, поэтому примеров может быть не так много.\n"
            "  Предложите ему посмотреть несколько кейсов по ссылке: Google Drive [https://drive.google.com/drive/folders/19jT_g8zWWfXtM8A9wgwOslzgIo7Da8gR?usp=drive_link].\n"
            "  После предоставления кейсов, задайте вопрос: \"Хотели бы вы получить консультацию, чтобы вы могли ближе познакомиться с процессом создания видеоконтента?\"\n\n"


            "# Если клиент спрашивает как реализуется данная технология/как происходит процесс создания таких видео\n"
               "Специальный сервис на основе ИИ обучается на примере вашего видео (жестикуляция и артикуляция). В другом сервисе мы обучаем нейросеть имитации вашей интонации и темпа речи (на основе аудио с вашим голосом).\n"
               "А сценарии мы создаем по такому алгоритму:\n"
               "1. Сбор популярных видео по вашей тематике\n" 
	       "2. Уникализация сценария видео и его адаптирование под вас\n"
               "3. Добавления структуры сценария (цепляющее первое предложение и окончание видео с призывом его сохранить /отправить другу или написания кодового слова в комментариях с целью получить бесплатный материал)\n"


            "# Если клиент спрашивает что от него потребуется для создания такого видео:\n"
               "От вас потребуется следующее:\n"
               "- трехминутное видео с вами\n"
               "- пятиминутное аудио с вашим голосом\n" 
               "- примеры коротких видео конкурентов, которые вам нравятся\n"

	   "#  Всегда будь вежлива при общении с клиентом. Если ты задаешь вопросы клиенту, то делай это максимально вежливо" 

	   "#  В кадом твоем сообщении должно быть не более 1 вопроса."	
        )
    }
]


# Промпты для нейросети 2 и 3 (оставлены пустыми)
prompt_template_2 = [
    {
        "role": "system",
        "content": (
            "Ты - Анастасия, молодая девушка 23 лет, менеджер комании Launch Ai, который упрощает создание видеоконтента с помощью AI-аватаров.(вашего виртуального персонажа, созданного с помощью искусственного интеллекта, который может говорить и вести себя как реальный человек.)"


            "Ты уже несколько лет работаешь в продажах и знаешь все тонкости, каждый твой вопрос продуман, ты знаешь зачем ты его задаешь, и каждый твой вопрос построен таким образом, что задевает основные боли клиента."


            "Твоя цель — продать услугу по созданию видео контента с помощью нейросетей клиенту через холодную рассылку, отвечая на сообщения пользователя.\n\n"

            "Обращай внимание на правильные окончания слов и склонение. Всегда используйте корректные формы в соответствии с русской грамматикой."


            "# Всегда выстраивай диалог следующим образом — Задавай по одному вопросу, дождись ответ. Проанализируй контекст, задавай следующий вопрос, и так до конца диалога.\n\n"


            "Действуй по шагам:\n"

            "#шаг 1. Изучи какой бюджет клиент закладывает на создание видео для соц сетей.\n"

	    "Проанализируй ответ пользователя. Проанализируй весь диалог и переходи к следующему шагу сверху вниз, если клиент уже ответил на вопрос из следующего шага иди дальше, проверяя каждый шаг до последнего."

            "если пользователь в своем сообщении высказал возражение, то найди ответ на него в {Ответы на вопросы} и отработай их. раздели сообщение на два абзаца, во втором спроси:"

            " 'Подскажите, какой бюджет вы закладываете на создание видеоконтента ежемесячно?'\n"

            "если пользователь в своем сообщении не высказал возражение а только назвал свой бюдет, просто  спроси:"

            " 'Подскажите, какой бюджет вы закладываете на создание видеоконтента ежемесячно?'\n"

            "#шаг 2. Изучи использует ли клиент нейросети в своей работе?\n"

	   "Проанализируй ответ пользователя. Проанализируй весь диалог и переходи к следующему шагу сверху вниз, если клиент уже ответил на вопрос из следующего шага иди дальше, проверяя каждый шаг до последнего."
	   "Если пользователь задал вопрос, то ответь на него в 2 предложениях, информацию как ответить на вопрос ищи в “ответы на вопросы” и также добавь в конце сообщения"
           "  \"Использовали ли вы ранее нейросети или другие автоматизированные инструменты в вашей работе?\"\n"
	   

           "Если клиент ответил '0' или то что он не закладывает бюджет на создание контента - это не возражение и не вопрос, не пытайся отрабатывать его. А если он к этой информации в своем сообщении добавил вопросы, то на них тебе надо ответить"

	   "Если пользователь не задал вопросов,а указал свой бюджет, то просто спроси у клиента 'Хорошо, Использовали ли вы ранее нейросети или другие автоматизированные инструменты в вашей работе?'. Не благодари клиента за ответ!. Если ты добавляешь фразы, которые не указаны в инструкции, это будет считаться ошибкой."

	   " **ВНИМАНИЕ: Задавай только один вопрос в каждом сообщении. Не добавляй вопросы, если клиент не дал ответ!**"
           




            "# шаг3. Предложи консультацию "  
            "После того как клиент в той или иной форме ответил на 2 вопроса выше (бюджет и использование нейросетей), предложи консультацию. Обязательно раздели сообщение на отдельные абзацы и добавь пустую строку между ними"

            "Твое сообщение: 'Благодарю вас за ответы!\n\nНе хотели бы вы провести консультацию с нашим менеджером, который готов ответить на все ваши вопросы о создании видеоконтента?\n\nКонсультация абсолютно бесплатна!'"

	    "Проанализируй ответ пользователя. Проанализируй весь диалог и переходи к следующему шагу сверху вниз, если клиент уже ответил на вопрос из следующего шага иди дальше, проверяя каждый шаг до последнего."


            "# Шаг 4. Если клиент согласился на проведение консультации из шага 3.Обязательно раздели сообщение на отдельные абзацы и добавь пустую строку между ними\n"
            "Замечательно! С вами свяжется наш менеджер в ближайшее время.\nЕго аккаунт: [@AI_griban](https://t.me/AI_griban).\" обязательно добавь хештег #спасибо\n\n"


            "# Если клиент отказывается от услуги и не хочет дальше вести диалог:\n"
            "  \"Хорошо, я вас поняла, если вы передумаете, то я всегда на связи!\" обязательно добавь хештег #спасибо\n\n"

            "# В каждом сообщении задавайте только один вопрос, за исключением последнего сообщения с контактами Алексея, где вопросов быть не должно.\n\n"

            "Если клиент спрашивает делаем ли мы 'пробное видео', то отправь ему контакты менеджера"

            "# ОТВЕТЫ НА ВОПРОСЫ:\n"

            "# Если клиент спрашивает, почему наши видео будут лучше, чем его собственные, или интересуется конверсией:\n"
            "  \"Объясните, что мы используем сразу несколько нейросетей для создания уникального контента.\n"
            "  Сообщите, что за основу берём уже популярные видео с миллионами просмотров из его или смежной темы, что обеспечивает высокие просмотры и повышает конверсию.\"\n\n"


            "# Если у клиента возникают сомнения, то подчеркни преимущества нашего сервиса:\n"
            "  \"Наше уникальное решение позволяет вам получать готовые видео быстро и без лишних усилий. ИИ создаёт сценарии и генерирует видео автоматически.\"\n"
            "  \"Это поможет вам сэкономить время и избежать задержек.\"\n\n"


            "#  Если клиент спрашивает про стоимость услуги, то скажи что базовая стоимость видео, длительностью до одной минуты, составляет 2000 рублей. Подробнее о тарифах можно узнать на консультации с менеджером.\n\n"
 
            "# Если клиент спрашивает, кто вы:\n"
            "  \"Представьтесь как Анастасия, менеджер компании Launch Ai. Расскажи ему о преимуществах нашего сервиса\""


           "# Если клиент спрашивает про кейсы работы:\n"
            "  \"Скажите, что с удовольствием поделитесь кейсами работы с данным методом.\n"
            "  Упомяните, что технология новая и начала массово использоваться несколько месяцев назад, поэтому примеров может быть не так много.\n"
            "  Предложите ему посмотреть несколько кейсов по ссылке: Google Drive [https://drive.google.com/drive/folders/19jT_g8zWWfXtM8A9wgwOslzgIo7Da8gR?usp=drive_link].\n"
            "  После предоставления кейсов, задайте вопрос: \"Хотели бы вы получить консультацию, чтобы вы могли ближе познакомиться с процессом создания видеоконтента?\"\n\n"


            "# При отправке сообщения с кейсами не добавляйте контактную информацию Алексея.\n\n"


            "# Если клиент соглашается на консультацию:\n"
            "  \"Предоставьте контактную информацию Алексея и укажите, что клиенту необходимо написать ему и назначить удобное время для консультации.\""


            "# Если клиент спрашивает как реализуется данная технология/как происходит процесс создания таких видео\n"
               "Специальный сервис на основе ИИ обучается на примере вашего видео (жестикуляция и артикуляция). В другом сервисе мы обучаем нейросеть имитации вашей интонации и темпа речи (на основе аудио с вашим голосом).\n"
               "А сценарии мы создаем по такому алгоритму:\n"
               "1. Сбор популярных видео по вашей тематике\n" 
	       "2. Уникализация сценария видео и его адаптирование под вас\n"
               "3. Добавления структуры сценария (цепляющее первое предложение и окончание видео с призывом его сохранить /отправить другу или написания кодового слова в комментариях с целью получить бесплатный материал)\n"


            "# Если клиент спрашивает что от него потребуется для создания такого видео:\n"
               "От вас потребуется следующее:\n"
               "- трехминутное видео с вами\n"
               "- пятиминутное аудио с вашим голосом\n" 
               "- примеры коротких видео конкурентов, которые вам нравятся\n"

           "#  Если клиент сразу хочет связаться с менеджером вежливо попроси его пройти предварительное анкетирование.\n"

	       "Проанализируй ответ пользователя. Проанализируй весь диалог и переходи к следующему шагу сверху вниз, если клиент уже ответил на вопрос из следующего шага иди дальше, проверяя каждый шаг до последнего."

	   "#  Всегда будь вежлива при общении с клиентом. Если ты задаешь вопросы клиенту, то делай это максимально вежливо" 

	   "#  В твоем сообщении должно быть не более 1 вопроса."
           
           "# Всегда будь вежлива"

           "# Всегда благодарите клиента только в шаге 3 или в конце диалога. В промежуточных сообщениях избегайте благодарностей."

           "# Обращай внимание на склонения и окончания. Не допускай ошибок"

   
        )
      }
    ]
prompt_template_3 = [
    {
        "role": "system",
        "content": (
            "Ты - Анастасия, молодая девушка 23 лет, менеджер комании Launch Ai, который упрощает создание видеоконтента с помощью AI-аватаров.(вашего виртуального персонажа, созданного с помощью искусственного интеллекта, который может говорить и вести себя как реальный человек.)"


            "Ты уже несколько лет работаешь в продажах и знаешь все тонкости, каждый твой вопрос продуман, ты знаешь зачем ты его задаешь, и каждый твой вопрос построен таким образом, что задевает основные боли клиента."


            "Твоя цель — продать услугу по созданию видео контента с помощью нейросетей клиенту через холодную рассылку, отвечая на сообщения пользователя.\n\n"

            "Обращай внимание на правильные окончания слов и склонение. Всегда используйте корректные формы в соответствии с русской грамматикой."


            "# Всегда выстраивай диалог следующим образом — Задавай по одному вопросу, дождись ответ. Проанализируй контекст, задавай следующий вопрос, и так до конца диалога.\n\n"


            "Действуй по шагам:\n"

            "#шаг 1. Изучи какой бюджет клиент закладывает на создание видео для соц сетей.\n"

	    "Проанализируй ответ пользователя. Проанализируй весь диалог и переходи к следующему шагу сверху вниз, если клиент уже ответил на вопрос из следующего шага иди дальше, проверяя каждый шаг до последнего."

	    "Задай следующий вопрос пользователю:\n\n"
            "Никогда не позно начать!<br>Скажите, если бы вы стали вести соц сети, то какой бюджет вы бы закладывали на создание видео?"


            "#шаг 2. Изучи использует ли клиент нейросети в своей работе?\n"

	   "Проанализируй ответ пользователя. Проанализируй весь диалог и переходи к следующему шагу сверху вниз, если клиент уже ответил на вопрос из следующего шага иди дальше, проверяя каждый шаг до последнего."
	   "Если пользователь задал вопрос, то ответь на него в 2 предложениях, информацию как ответить на вопрос ищи в “ответы на вопросы” и также добавь в конце сообщения"
           "  \"Использовали ли вы ранее нейросети или другие автоматизированные инструменты в вашей работе?\"\n"
	   

           "Если клиент ответил '0' или то что он не закладывает бюджет на создание контента - это не возражение и не вопрос, не пытайся отрабатывать его. А если он к этой информации в своем сообщении добавил вопросы, то на них тебе надо ответить"

	   "Если пользователь не задал вопросов,а указал свой бюджет, то просто спроси у клиента: 'Хорошо, Использовали ли вы ранее нейросети или другие автоматизированные инструменты в вашей работе?'"


            "# шаг3. Предложи консультацию "
          
            "После того как клиент в той или иной форме ответил на 2 вопроса выше,  если он заинтересован, спроси не хотел бы он провести консультацию с менеджером, который готов ответить на все вопросы.\n\n"
            
            "Перед вопросом о проведении консультации отсупи 1 красную строку и раздели это сообщение на 2 абазаца."

	    "Проанализируй ответ пользователя. Проанализируй весь диалог и переходи к следующему шагу сверху вниз, если клиент уже ответил на вопрос из следующего шага иди дальше, проверяя каждый шаг до последнего."


            "# Шаг 4. Если клиент согласился на проведение консультации из шага 3.\n"
            "Замечательно! С вами свяжется наш менеджер в ближайшее время.<br>Его аккаунт: [@AI_griban](https://t.me/AI_griban). Консультация абсолютно бесплатна!\" обязательно добавь хештег #спасибо\n\n"


            "# Если клиент отказывается от услуги и не хочет дальше вести диалог:\n"
            "  \"Хорошо, я вас поняла, если вы передумаете, то я всегда на связи!\" обязательно добавь хештег #спасибо\n\n"


            "# В каждом сообщении задавайте только один вопрос, за исключением последнего сообщения с контактами Алексея, где вопросов быть не должно.\n\n"

            "Если клиент спрашивает делаем ли мы 'пробное видео', то отправь ему контакты менеджера"

            "# ОТВЕТЫ НА ВОПРОСЫ:\n"

            "# Если клиент спрашивает, почему наши видео будут лучше, чем его собственные, или интересуется конверсией:\n"
            "  \"Объясните, что мы используем сразу несколько нейросетей для создания уникального контента.\n"
            "  Сообщите, что за основу берём уже популярные видео с миллионами просмотров из его или смежной темы, что обеспечивает высокие просмотры и повышает конверсию.\"\n\n"


            "# Если у клиента возникают сомнения, то подчеркни преимущества нашего сервиса:\n"
            "  \"Наше уникальное решение позволяет вам получать готовые видео быстро и без лишних усилий. ИИ создаёт сценарии и генерирует видео автоматически.\"\n"
            "  \"Это поможет вам сэкономить время и избежать задержек.\"\n\n"


            "#  Если клиент спрашивает про стоимость услуги, то скажи что базовая стоимость видео, длительностью до одной минуты, составляет 2000 рублей. Подробнее о тарифах можно узнать на консультации с менеджером.\n\n"
 

           "# Если клиент спрашивает про кейсы работы:\n"
            "  \"Скажите, что с удовольствием поделитесь кейсами работы с данным методом.\n"
            "  Упомяните, что технология новая и начала массово использоваться несколько месяцев назад, поэтому примеров может быть не так много.\n"
            "  Предложите ему посмотреть несколько кейсов по ссылке: Google Drive [https://drive.google.com/drive/folders/19jT_g8zWWfXtM8A9wgwOslzgIo7Da8gR?usp=drive_link].\n"
            "  После предоставления кейсов, задайте вопрос: \"Хотели бы вы получить консультацию, чтобы вы могли ближе познакомиться с процессом создания видеоконтента?\"\n\n"


            "# При отправке сообщения с кейсами не добавляйте контактную информацию Алексея.\n\n"


            "# Если клиент соглашается на консультацию:\n"
            "  \"Предоставьте контактную информацию Алексея и укажите, что клиенту необходимо написать ему и назначить удобное время для консультации.\""


            "# Если клиент спрашивает как реализуется данная технология/как происходит процесс создания таких видео\n"
               "Специальный сервис на основе ИИ обучается на примере вашего видео (жестикуляция и артикуляция). В другом сервисе мы обучаем нейросеть имитации вашей интонации и темпа речи (на основе аудио с вашим голосом).\n"
               "А сценарии мы создаем по такому алгоритму:\n"
               "1. Сбор популярных видео по вашей тематике\n" 
	       "2. Уникализация сценария видео и его адаптирование под вас\n"
               "3. Добавления структуры сценария (цепляющее первое предложение и окончание видео с призывом его сохранить /отправить другу или написания кодового слова в комментариях с целью получить бесплатный материал)\n"


            "# Если клиент спрашивает что от него потребуется для создания такого видео:\n"
               "От вас потребуется следующее:\n"
               "- трехминутное видео с вами\n"
               "- пятиминутное аудио с вашим голосом\n" 
               "- примеры коротких видео конкурентов, которые вам нравятся\n"

           "#  Если клиент сразу хочет связаться с менеджером вежливо попроси его пройти предварительное анкетирование.\n"

	       "Проанализируй ответ пользователя. Проанализируй весь диалог и переходи к следующему шагу сверху вниз, если клиент уже ответил на вопрос из следующего шага иди дальше, проверяя каждый шаг до последнего."

	   "#  Всегда будь вежлива при общении с клиентом. Если ты задаешь вопросы клиенту, то делай это максимально вежливо" 

	   "#  В кадом твоем сообщении должно быть не более 1 вопроса."

	   "#  При отправке сообщения с хештегом (#спасибо) ты не задаешь вопросов."

           "# Всегда будь вежлива"

           "# Всегда благодарите клиента только в шаге 3 или в конце диалога. В промежуточных сообщениях избегайте благодарностей."         
        )
      }
    ]

# Новый шаблон для анализа квалификации
qualification_prompt_template = {
    "role": "system",
    "content": (
        "Ты являешься специалистом по аналитике, а также по квалификации лидов. Твоя задача - определить квалификацию. "
        "Как определить квалификацию: \n"
        "1. Холодный клиент - клиент не идет на контакт, отказывается говорить про создание видео, спрашивает только стоимость и всё.\n"
        "2. Теплый клиент - клиент, который задумывается о создании контента с использованием предлагаемой услуги, но пока не готов на созвон, но активно задает вопросы.\n"
        "3. Горячий клиент - клиент, который активно отвечает на вопросы и готов провести консультацию с менеджером.\n\n"
        "# если клиент пишет 15к, 15к = это значит 15.000\n\n"
        "# Действуй по инструкции:\n"
        "Проанализируй диалог, определи квалификацию. Проведи саммари диалога.\n"
        "Выведи ответ с ключами: qualification, summary, monthly_budget (выведи число, если клиент в процессе диалога не указал, считать его '0'), "
        "consultation_agreed (если клиент не ответил на вопрос о консультации, считать его 'неясно'). Пришли ответ в формате JSON."
    )
}

# Анализ ведения соц сетей
seti_prompt_template = [
        {
            "role": "system",
            "content": (
                "Проанализируй весь диалог и определи, ведет ли клиент соцсети самостоятельно. "
                "Дай ответ в формате ключ: Vedet(да/нет/неясно).Пришли ответ в формате JSON. "
            )
        }
    ]



def validate_messages(messages):
    if not isinstance(messages, list):
        raise ValueError("Expected 'messages' to be a list.")
    for msg in messages:
        if not isinstance(msg, dict):
            raise ValueError("Each message should be a dictionary.")
        if "role" not in msg or "content" not in msg:
            raise ValueError("Each message dictionary should contain 'role' and 'content'.")

# Обновленная функция для получения ответа от нейросети 1
async def get_4o_answer(messages, max_retries=3, temperature=0.7, top_p=0.6):
    retries = 0
    # Объединяем начальный промпт с контекстом сообщений
    full_context = prompt_template_1.copy()
    full_context.extend(messages)

    print(f"Запускаем get_4o_answer с контекстом: {full_context}")  # Лог перед отправкой в API
    while retries < max_retries:
        try:
            print(f"Попытка #{retries + 1} отправки запроса к OpenAI API")  # Лог попытки вызова API
            response = await openai.ChatCompletion.acreate(
                model="gpt-4o-mini",
                messages=full_context,
                temperature=temperature,
                top_p=top_p
            )
            content = response['choices'][0]['message']['content'].strip()
            print(f"Ответ от модели: {content}")  # Логируем ответ
            return content
        except openai.error.RateLimitError as e:
            print(f"Превышен лимит запросов к OpenAI API: {e}")
            retries += 1
        except openai.error.APIConnectionError as e:
            print(f"Ошибка подключения к OpenAI API: {e}")
            retries += 1
        except openai.error.InvalidRequestError as e:
            print(f"Некорректный запрос к OpenAI API: {e}")
            break
        except Exception as e:
            print(f"Неизвестная ошибка при запросе к OpenAI API: {e}")
            retries += 1

    print(f"Не удалось получить ответ после {retries} попыток")
    return "Извините, мне сейчас неудобно слушать ваше сообщение в таком формате. Можете написать текстом?"




# Обновленная функция для получения ответа от нейросети 2
async def get_4o_answer_vedet(messages, max_retries=3, temperature=0.5, top_p=0.7):
    retries = 0
    full_context = prompt_template_2.copy()
    full_context.extend(messages)

    print(f"Запускаем get_4o_answer с контекстом: {full_context}")  # Лог перед отправкой в API
    while retries < max_retries:
        try:
            response = await openai.ChatCompletion.acreate(
                model="gpt-4o-mini",
                messages=full_context,
                temperature=temperature,
                top_p=top_p
            )
            content = response['choices'][0]['message']['content'].strip()
            print(f"Ответ от модели: {content}")
            return content
        # Обработка исключений
        except openai.error.RateLimitError as e:
            print(f"Превышен лимит запросов к OpenAI API: {e}")
            retries += 1
        except openai.error.APIConnectionError as e:
            print(f"Ошибка подключения к OpenAI API: {e}")
            retries += 1
        except openai.error.InvalidRequestError as e:
            print(f"Некорректный запрос к OpenAI API: {e}")
            break
        except Exception as e:
            print(f"Неизвестная ошибка при запросе к OpenAI API: {e}")
            retries += 1

    print(f"Не удалось получить ответ после {retries} попыток")
    return "Извините, мне сейчас неудобно слушать ваше сообщение в таком формате. Можете написать текстом?"




# Обновленная функция для получения ответа от нейросети 3
async def get_4o_answer_nevedet(messages, max_retries=3, temperature=0.5, top_p=0.7):
    retries = 0
    full_context = prompt_template_3.copy()
    full_context.extend(messages)

    print(f"Запускаем get_4o_answer с контекстом: {full_context}")  # Лог перед отправкой в API
    while retries < max_retries:
        try:
            response = await openai.ChatCompletion.acreate(
                model="gpt-4o-mini",
                messages=full_context,
                temperature=temperature,
                top_p=top_p
            )
            content = response['choices'][0]['message']['content'].strip()
            print(f"Ответ от модели: {content}")
            return content
        # Обработка исключений
        except openai.error.RateLimitError as e:
            print(f"Превышен лимит запросов к OpenAI API: {e}")
            retries += 1
        except openai.error.APIConnectionError as e:
            print(f"Ошибка подключения к OpenAI API: {e}")
            retries += 1
        except openai.error.InvalidRequestError as e:
            print(f"Некорректный запрос к OpenAI API: {e}")
            break
        except Exception as e:
            print(f"Неизвестная ошибка при запросе к OpenAI API: {e}")
            retries += 1

    print(f"Не удалось получить ответ после {retries} попыток")
    return "Извините, мне сейчас неудобно слушать ваше сообщение в таком формате. Можете написать текстом?"




# Функция для сохранения диалога в файл
def save_dialog_to_file(username, messages):
    user_log_file = os.path.join(LOGS_DIR, f"{username}.txt")
    with open(user_log_file, 'a', encoding='utf-8') as file:
        for message in messages:
            file.write(f"{message['role'].capitalize()}: {message['content']}\n\n")

# Функция для отправки приветственного сообщения и запуска таймера
async def send_message(client, username, initial_message, context, conn):
    try:
        logging.info(f"Отправка сообщения пользователю {username}: {initial_message}")

        # Убедимся, что 'stats' есть в context
        if 'stats' not in context:
            context['stats'] = {}

        # Убедимся, что для конкретного пользователя есть запись в 'stats'
        if username not in context['stats']:
            context['stats'][username] = {
                "user_replied": False,
                "message_count": 0,
                "sensitive_info_sent": False,
                "initial_message_sent": True,
                "reminder_sent": False  # Инициализация reminder_sent
            }

        await client.send_message(username, initial_message)
        logging.info(f"Приветственное сообщение успешно отправлено пользователю {username}")

        # Обновляем статистику после отправки сообщения
        await log_and_update_stats_db(
            conn,
            username=username,
            user_replied=False,
            message_count=0,
            sensitive_info_sent=False,
            initial_message_sent=True
        )

        # Запускаем таймер на 2 часа для отправки напоминания
        asyncio.create_task(reminder_timer(client, username, context, conn))
        await asyncio.sleep(1)
    except Exception as e:
        logging.error(f"Ошибка при отправке сообщения пользователю {username}: {e}")

# Функция, запускающая таймер на 2 часа
async def reminder_timer(client, username, context, conn):
    reminder_message = (
        "Хотелось бы задать вам буквально пару вопросов — это не займет много времени.\n"
        "Буду рада вашему ответу!"
    )
    try:
        # Ждем 2 часа (7200 секунд)
        await asyncio.sleep(30)

        # Проверяем, если пользователь не ответил и напоминание еще не отправлено
        if not context['stats'][username]['user_replied'] and not context['stats'][username]['reminder_sent']:
            await client.send_message(username, reminder_message)
            context['stats'][username]['reminder_sent'] = True
            # Логируем отправку напоминания в базу данных
            await log_and_update_stats_db(
                conn,
                username=username,
                user_replied=False,
                message_count=context['stats'][username].get('message_count', 0),
                sensitive_info_sent=False,
                initial_message_sent=context['stats'][username].get('initial_message_sent', False)
            )
    except asyncio.CancelledError:
        # Если таймер был отменен, просто выходим
        return

context = {}

# Обработчик ответов от пользователей
async def handle_response(client, context, conn):
    @client.on_message()
    async def on_message(client, message):
        print("Получено сообщение от пользователя")
        username = message.chat.username if message.chat.username else "unknown_user"

        # Проверяем, если пользователь уже есть в статистике
        if username in context['stats']:
            context['stats'][username]['user_replied'] = True


        # Если таймер на напоминание существует, отменяем его
        if username in timers:
            timers[username].cancel()
            del timers[username]

        # Логируем ответ пользователя в базу данных
        await log_and_update_stats_db(
            conn,
            username=username,
            user_replied=True,
            message_count=context['stats'][username].get('message_count', 0) + 1,
            sensitive_info_sent=False,
            initial_message_sent=context['stats'][username].get('initial_message_sent', False)
        )


        # Проверка на тип сообщения (голосовое сообщение, стикеры и т.д.)
        if message.voice or message.video_note:
            print(f"Пользователь {username} отправил неподдерживаемый тип сообщения.")
            ai_response = "Извините, мне сейчас неудобно слушать ваше сообщение в таком формате. Можете написать текстом?"
            await client.send_message(username, ai_response)
            return

        if message.sticker:
            print(f"Пользователь {username} отправил стикер.")
            ai_response = "Извините, мне сейчас неудобно обрабатывать стикеры. Можете написать текстом?"
            await client.send_message(username, ai_response)
            return

        # Инициализация контекста для нового пользователя
        if username not in context:
            print(f"Инициализация контекста для {username}")
            context[username] = []

        # Добавляем сообщение пользователя в буфер (user_messages)
        user_messages[username].append({"role": "user", "content": message.text})

        # Сбрасываем таймер на 15 секунд, после которого будет отправлен ответ
        await reset_timer(username, client, conn)

# Функция для сброса и обновления таймера
async def reset_timer(username, client, conn):
    # Проверяем, есть ли активный таймер для пользователя, и отменяем его
    if username in timers:
        print(f"Сбрасываем таймер для пользователя {username}")
        timers[username].cancel()  # Отменяем предыдущий таймер

    # Запускаем новый таймер
    timers[username] = asyncio.create_task(start_timer(username, client, conn))

# Обновление функции start_timer для анализа и переключения на следующий промпт
async def start_timer(username, client, conn):
    print(f"Запускаем таймер для пользователя {username} на 15 секунд")
    await asyncio.sleep(15)  # Ожидаем 15 секунд

    if username in user_messages and user_messages[username]:
        print(f"Таймер для пользователя {username} истек. Формируем запрос к нейросети.")

        # Инициализация контекста, если это новый пользователь
        if username not in context:
            context[username] = {
                "messages": [],
                "use_alternate_prompt": False,
                "in_secondary_prompt": False,
                "current_prompt": 1  # Начинаем с первого промпта
            }

        # Добавляем временные сообщения в основной контекст
        context[username]["messages"].extend(user_messages[username])
        user_messages[username].clear()  # Очищаем временный буфер сообщений

        save_dialog_to_file(username, context[username]["messages"])  # Сохраняем сообщения пользователя

        try:
            # Проверяем, если мы уже на втором или третьем промпте
            if context[username]["in_secondary_prompt"]:
                # Проверка на текущий промпт (2 или 3)
                if context[username]["current_prompt"] == 2:
                    ai_response = await get_4o_answer_vedet(context[username]["messages"])
                elif context[username]["current_prompt"] == 3:
                    ai_response = await get_4o_answer_nevedet(context[username]["messages"])
            else:
                # Используем первый промпт по умолчанию
                full_context = prompt_template_1.copy()
                full_context.extend(context[username]["messages"])  # Добавляем все сообщения пользователя
                ai_response = await get_4o_answer(full_context)

                # Проверка на триггер "Хорошо <3" в ответе нейросети
                if "хорошо <3" in ai_response.lower():
                    print(f"Найден триггер 'Хорошо <3' в ответе нейросети. Переключаемся на другой промпт.")
                    context[username]["use_alternate_prompt"] = True
                    context[username]["in_secondary_prompt"] = True  # Устанавливаем, что теперь в процессе второго или третьего промпта

                    # Выполняем анализ для выбора второго или третьего промпта
                    seti_analysis_result = await seti_analyze_qualification(context[username]["messages"])
                    if seti_analysis_result:
                        Vedet = seti_analysis_result.get("Vedet")
                        print(f"Анализ соцсетей после 'Хорошо <3': {seti_analysis_result}")

                        if Vedet == "да":
                            context[username]["current_prompt"] = 2  # Устанавливаем, что теперь используем второй промпт
                            ai_response = await get_4o_answer_vedet(context[username]["messages"])
                        elif Vedet == "нет":
                            context[username]["current_prompt"] = 3  # Переключаемся на третий промпт
                            ai_response = await get_4o_answer_nevedet(context[username]["messages"])
                        else:
                            ai_response = "Извините, мне сейчас неудобно обработать ваш запрос."

            # Отправляем ответ пользователю и добавляем в контекст
            if ai_response:
                print(f"Отправляем ответ пользователю {username}: {ai_response}")
                await client.send_message(username, ai_response)
                context[username]["messages"].append({"role": "assistant", "content": ai_response})

            if "коммерческое предложение" in ai_response.lower():
                print(f"Найдено упоминание 'коммерческое предложение'. Отправляем документ.")
                await client.send_document(
                    chat_id=username,
                    document="/opt/Project501/LaunchAi.pdf"
                )

            await log_and_update_stats_db(
                conn,
                username=username,
                user_replied=True,
                message_count=len(context[username]["messages"]),
                sensitive_info_sent=("https://t.me/AI_griban" in ai_response),
                initial_message_sent=True
            )

            # Проверка на хештег "#спасибо" в ответе
            if "#спасибо" in ai_response.lower() and context[username]["in_secondary_prompt"]:
                print(f"Найден хештег '#спасибо' в ответе пользователю {username}. Запускаем анализ квалификации.")
                analysis_result = await analyze_qualification(context[username]["messages"])

                if analysis_result:
                    consultation_agreed = analysis_result.get('consultation_agreed', False)
                    consultation_agreed = consultation_agreed.lower() == 'да' if isinstance(consultation_agreed, str) else consultation_agreed
                    await log_and_update_stats_db(
                        conn,
                        username=username,
                        user_replied=True,
                        message_count=len(context[username]["messages"]),
                        sensitive_info_sent=("https://t.me/AI_griban" in ai_response),
                        initial_message_sent=True,
                        qualification=analysis_result.get("qualification"),
                        summary=analysis_result.get("summary"),
                        monthly_budget=analysis_result.get("monthly_budget"),
                        consultation_agreed=consultation_agreed
                    )
                else:
                    print(f"Не удалось получить результат анализа квалификации для пользователя {username}.")


        except Exception as e:
            print(f"Ошибка при получении ответа от модели для пользователя {username}: {e}")
    else:
        print(f"Новое сообщение от пользователя {username} пришло, таймер сброшен.")


async def update_database_with_analysis(analysis_result, username, conn):
    try:
        qualification = analysis_result.get('qualification')
        summary = analysis_result.get('summary')
        monthly_budget = analysis_result.get('monthly_budget')
        consultation_agreed = analysis_result.get('consultation_agreed', False)

        await conn.execute("""
            UPDATE user_stats
            SET qualification = $1,
                summary = $2,
                monthly_budget = $3,
                consultation_agreed = $4,
                updated_at = CURRENT_TIMESTAMP
            WHERE username = $5;
        """, qualification, summary, monthly_budget, consultation_agreed, username)
        print(f"База данных успешно обновлена для пользователя {username}.")
    except Exception as e:
        print(f"Ошибка при обновлении базы данных для пользователя {username}: {e}")




# Функция для анализа ведения соц сетей
async def seti_analyze_qualification(dialogue):
    def parse_analysis_result(content):
        try:
            # Попробуем найти JSON в содержимом ответа
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            json_content = content[json_start:json_end]

            # Парсинг JSON из извлеченного содержимого
            analysis_result = json.loads(json_content)
            return analysis_result
        except json.JSONDecodeError:
            print(f"Ошибка парсинга JSON: {content}")
            return None

    # Формируем полный контекст для анализа
    analysis_context = seti_prompt_template.copy()
    analysis_context.extend(dialogue)

    try:
        response = await openai.ChatCompletion.acreate(
            model="gpt-4o-mini",
            messages=analysis_context,
            temperature=0.5,
            top_p=0.9
        )
        content = response['choices'][0]['message']['content']
        print(f"Ответ от модели для анализа ведения соцсетей: {content}")  # Вывод ответа от модели

        # Парсим ответ от модели
        analysis_result = parse_analysis_result(content)
        if not analysis_result:
            print("Анализ результата вернул None. Проверьте формат ответа от модели.")
        return analysis_result
    except Exception as e:
        print(f"Ошибка при анализе ведения соцсетей: {e}")
        return None





# Функция для анализа квалификации
async def analyze_qualification(dialogue):
    def parse_analysis_result(content):
        import json
        try:
            analysis_result = json.loads(content)
            return analysis_result
        except json.JSONDecodeError:
            lines = content.split('\n')
            result = {}

            for line in lines:
                if line.strip().startswith('{') or line.strip().startswith('}'):
                    continue

                if ':' in line:
                    key, value = line.strip().split(':', 1)
                    key = key.strip().replace('"', '')
                    value = value.strip().replace('"', '')

                    if key == 'qualification':
                        result[key] = value
                    elif key == 'summary':
                        result[key] = value
                    elif key == 'monthly_budget':
                        if value.lower() == 'null':
                            result[key] = None
                        else:
                            result[key] = int(value.replace(',', ''))
                    elif key == 'consultation_agreed':
                        result[key] = value.lower() == 'true'
                else:
                    match = re.match(r'"(\w+)":\s*(.*)', line)
                    if match:
                        key, value = match.groups()
                        result[key] = value

            return result

    # Формируем полный контекст для анализа
    analysis_context = [
        qualification_prompt_template,
    ]
    analysis_context.extend(dialogue)

    try:
        response = await openai.ChatCompletion.acreate(
            model="gpt-4o-mini",  # Используйте подходящую модель
            messages=analysis_context,
            temperature=0.5,
            top_p=0.9
        )
        content = response['choices'][0]['message']['content']
        print(f"Ответ от модели для анализа квалификации: {content}")

        # Парсим ответ от модели
        analysis_result = parse_analysis_result(content)
        return analysis_result
    except Exception as e:
        print(f"Ошибка при анализе квалификации: {e}")
        return None

    # Формируем полный контекст для анализа
    analysis_context = [
        qualification_prompt_template,
    ]
    analysis_context.extend(dialogue)

    try:
        response = await openai.ChatCompletion.acreate(
            model="gpt-4o-mini",  # Используйте подходящую модель
            messages=analysis_context,
            temperature=0.5,
            top_p=0.9
        )
        content = response['choices'][0]['message']['content']
        print(f"Ответ от модели для анализа квалификации: {content}")

        # Парсим ответ от модели
        analysis_result = parse_analysis_result(content)
        return analysis_result
    except Exception as e:
        print(f"Ошибка при анализе квалификации: {e}")
        return None
  


# Определяем названия столбцов для юзернеймов и имен клиентов
username_column = 'Script1'
name_column = 'Script1name'

# Основная функция выполнения программы
async def main(index_name):
    clients = []
    context = {}
    users_processed = 0
    max_users_per_day = 2

    conn = await create_db_connection()

    for account in accounts:
        client = Client(account['session_name'])
        await client.start()
        clients.append(client)

        # Регистрация обработчика сообщений
        asyncio.create_task(handle_response(clients[0], context, conn))

    try:
        while True:
            if users_processed < max_users_per_day:
                start_index = await get_current_index(conn, index_name)
                logging.info(f"Текущий индекс в работе: {start_index}")  # Логируем индекс
                
                # Вызов функции и передача названий столбцов
                username, client_name, next_index = load_single_username_from_excel(username_column, name_column, start_index)

                if username and client_name:
                    logging.info(f"Username взят в работу: {username}, Имя клиента: {client_name}")  # Логируем username и имя
                    
                    # Форматируем приветственное сообщение с использованием имени клиента
                    personalized_message = initial_message.replace('Script1name', client_name)
                    
                    # Отправляем сообщение
                    await send_message(clients[0], username, personalized_message, context, conn)
                    
                    # Обновляем индекс
                    await update_current_index(conn, next_index, index_name)
                    
                    users_processed += 1

                    if users_processed < max_users_per_day:
                        await asyncio.sleep(1200)  # Ждем 1200 сек 20 мин перед обработкой следующего пользователя
                else:
                    logging.info("Нет больше пользователей для обработки")
                    break
            else:
                now = datetime.now()
                tomorrow = now + timedelta(days=1)
                next_run_time = datetime(tomorrow.year, tomorrow.month, tomorrow.day, 11, 0, 0)

                wait_time = (next_run_time - now).total_seconds()
                logging.info(f"Все пользователи обработаны. Ждем до {next_run_time}")
                await asyncio.sleep(wait_time)

                users_processed = 0

        # Бесконечный цикл для удержания скрипта активным
        while True:
            await asyncio.sleep(3600)  # Периодически спим, чтобы не занимать ресурсы
    finally:
        await conn.close()
        for client in clients:
            await client.stop()

# Запуск скрипта с указанием уникального имени индекса
if __name__ == "__main__":
    asyncio.run(initialize_tables())  # Инициализируем таблицы перед запуском main
    asyncio.run(main(index_name))